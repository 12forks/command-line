#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros -Q -- $0 "$@"
|#
(defpackage :ros.script.fork-search.3679653190
  (:use :cl))
(in-package :ros.script.fork-search.3679653190)

(defvar *test-repo* "marijnh/Postmodern")

;; suppress output from loading libraries
(with-output-to-string (*standard-output*)
  (ql:quickload :drakma)
  (ql:quickload :babel)
  (ql:quickload :jonathan))


(defun repo-author (repo)
  "For 'svetlyak40wt/foo@bar' string returns 'svetlyak40wt'"
  (subseq repo 0 (position #\/ repo)))


(defun last-character (string)
  (aref string (1- (length string))))


(defun beautify-sentence (sentence)
  "Normalizes piece of text by capitalizing first character and adding dot at the end if needed."
  (let* ((length (length sentence))
         (last-char (last-character sentence))
         (capitalized (string-capitalize sentence :end (min 1 length))))
    (if (alphanumericp last-char)
        ;; add a dot
        (concatenate 'string capitalized ".")
        capitalized)))


(defun repo-branch (repo)
  "For 'svetlyak40wt/foo@bar' string returns 'bar'.
   If there is no @ suffix, assume 'master' is default branch."
  (let ((position (position #\@ repo)))
    (if position
        (subseq repo (1+ position))
        "master")))


(defun get-commit-message (commit)
  (let* ((commit-data (getf commit :|commit|))
         (message (getf commit-data :|message|)))
    message))


(defun get-data (path &rest params)
  (let* ((full-path (apply #'format (append (list nil path) params)))
         (url (concatenate 'string "https://api.github.com" full-path)))
    
    (multiple-value-bind (content code)
        (drakma:http-request url :force-binary t
                             :basic-authorization '("svetlyak40wt" "n29YR1DG1T"))
      
      (let ((decoded (babel:octets-to-string content :encoding :utf-8)))
        (assert (= code 200))
        (jonathan:parse decoded)))))


(defun get-fork-commits (base fork)
  "Returns a list of strings with commit messages"
  
  (let* ((data (get-data "/repos/~A/compare/~A:~A...~A:~A"
                     base
                     (repo-author base)
                     (repo-branch base)
                     (repo-author fork)
                     (repo-branch fork))))
    (mapcar #'get-commit-message (getf data :|commits|))))


(defun get-repo-branch-names (repo)
  "Takes string like 'svetlyak40wt/foo' and
returns a list of strings like 'svetlyak40wt/foo@master',
'svetlyak40wt/foo@some-feature', etc."
  (let ((data (get-data "/repos/~A/branches" repo)))
    (mapcar (lambda (item)
              (concatenate 'string
                           repo
                           "@"
                           (getf item :|name|)))
            data)))


(defun get-repo-forks (repo)
  "Takes string like \"svetlyak40wt/foo\" and
returns a list of fork names strings like (list \"some-person/foo\" \"other/foo\")

TODO: add pagination"
  
  (let ((data (get-data "/repos/~A/forks" repo)))
    (mapcar (lambda (item)
              (getf item :|full_name|))
            data)))


(defun strip (text)
  "Removes spaces and newlines from both ends of the string"
  (string-trim '(#\Space #\Newline) text))


(defun split-header (text)
  "Separates first line from the rest and
returns a list of two items. First line should be separated
from the rest with at least one empty line."
  (let ((pos (position #\Newline text)))
    (if pos
        (list (strip (subseq text 0 pos))
              (strip (subseq text (1+ pos))))
        (list (strip text) ""))))


(defun print-commit (message)
  "Prints to stdout as a reStructured document's secion.
First line becomes a header, rest â€“ a body."
  (format t "~A~%~%"
          (beautify-sentence message)))


(defun analyze-branch (base branch-full-name)
  "Fetches from a github commit messages of commits
   Returns a plist like that:

   (list :name <short-name-of-the-branch>
         :commits (list <commits))"
  
  (list :name (repo-branch branch-full-name)
        :commits (get-fork-commits base branch-full-name)))


(defun make-underline (char header)
  "Makes from given char a string of same length as text 'header'"
  (make-string (length header) :initial-element char))


(defun print-branch (branch)
  "Fetches from a github commit messages of commits

Then each commit message is printed to stdout as a reStructured
document's secion"
  
  (let ((commits (getf branch :commits))
        (branch-name (getf branch :name)))
    (format t "~A~%~A~%~%"
            branch-name
            (make-underline #\- branch-name))
    (mapc #'print-commit commits)
    nil))


(defun analyze-fork (base fork-name)
  "Returns a plist of fork data like
   '(:branches <branches-data> :name <fork-name>)

   Branches contains only having non merged to \"base\" commits."
  
  (let* ((branche-names (get-repo-branch-names fork-name))
         (all-branches (mapcar (lambda (branch-name)
                                 (analyze-branch base branch-name))
                               branche-names))
         (good-branches (remove-if-not
                         (lambda (branch)
                           (getf branch :commits))
                         all-branches)))
    (list :name fork-name
          :branches good-branches)))


(defun print-fork (fork)
  (let ((branches (getf fork :branches))
        (name (getf fork :name)))
    (format t "~A~%~A~%~%" name (make-underline #\= name))
    (mapc (lambda (branch)
            (print-branch branch))
          branches)
    nil))



(defun analyze-repo (repo)
  "Returns a plist of fork which have unmerged commits:
   (list :name <repo-name> :forks <forks>"
  
  (let* ((fork-names (get-repo-forks repo))

         (all-forks (mapcar (lambda (fork-name)
                          (analyze-fork repo fork-name))
                            fork-names))
         (good-forks (remove-if-not
                      (lambda (fork)
                        (getf fork :branches))
                      all-forks)))
    (list :name repo
          :forks good-forks
          :total-forks-count (length all-forks)
          :good-forks-count  (length good-forks))))


(defun print-repo (repo)
  "Prints repo data in reStructured text format"
  (let* ((forks (getf repo :forks))
         (repo-name (getf repo :name))
         (underline (make-underline #\= repo-name)))
    
    (format t "~A~%~A~%~A~%~%"
            underline
            repo-name
            underline)
    
    (if forks
        (progn (mapc (lambda (fork)
                       (print-fork fork))
                     forks)
               nil)
        (format t "No forks"))))


(defun main (&rest argv)
  (declare (ignorable argv))
  (let ((repo-data (analyze-repo (car argv))))
    (print-repo repo-data)))

;;; vim: set ft=lisp lisp:
