#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros -Q -- $0 "$@"
|#
(defpackage :12forks.cli
  (:use :cl))
(in-package :12forks.cli)


(defvar *test-repo* "marijnh/Postmodern")
(defvar *ignore-merges* t)

(defvar *config* nil)

(defconstant +config-help-messages+
  '(:token "Please set :token in .12forks file. It is required. It can be OAuth token or created at https://github.com/settings/tokens/new"))


(defun read-config (&optional (filename "./.12forks"))
  (with-open-file (f filename)
    (setf *config* (read f))
    (format nil "Config: ~A~%" *config*)))


(defun get-config (name)
  (let ((value (getf *config* name)))
    (if value
        value
        (error (getf +config-help-messages+
                     name
                     (format nil "Config value :~A is required.~%"
                             (string-downcase (symbol-name name))))))))


;; load libraries suppressing output from QuickLisp
(ql:quickload '(:drakma :babel :jonathan)
              :silent t)

;; suppress requiring for CC environment variable
;; (with-output-to-string (*error-output*)
;;   (ql:quickload '(:net.didierverna.clon)
;;                 :silent t))
(ql:quickload '(:net.didierverna.clon)
                :silent t)

(use-package :net.didierverna.clon)

(defun info (message &rest args)
  (let ((formatted-message (apply #'format (append (list nil message) args))))
    (format *error-output* "~A~%" formatted-message)))


(defun repo-name (repo)
  "Strips branch name from full repo name.
   For text like \"some/repo@master\" returns
   \"some/repo\"."
  (subseq repo
          0
          (position #\@ repo)))


(defun repo-author (repo)
  "For 'svetlyak40wt/foo@bar' string returns 'svetlyak40wt'"
  (subseq repo 0 (position #\/ repo)))


(defun last-character (string)
  (aref string (1- (length string))))


(defun beautify-sentence (sentence)
  "Normalizes piece of text by capitalizing first character and adding dot at the end if needed."
  (let* ((length (length sentence))
         (last-char (last-character sentence))
         (capitalized (string-capitalize sentence :end (min 1 length))))
    (if (alphanumericp last-char)
        ;; add a dot
        (concatenate 'string capitalized ".")
        capitalized)))

(defun merge-commit-p (commit)
  "If messages is looks like a merge commit, then.
   We consider merge commit if it has more than one parent"
  (> (length (getf commit :|parents|))
     1))


(defun repo-branch (repo)
  "For 'svetlyak40wt/foo@bar' string returns 'bar'.
   If there is no @ suffix, assume 'master' is default branch."
  (let ((position (position #\@ repo)))
    (if position
        (subseq repo (1+ position))
        "master")))


(defun get-commit-message (commit)
  (let* ((commit-data (getf commit :|commit|))
         (message (getf commit-data :|message|)))
    message))


(defun get-data (path &rest params)
  (let* ((full-path (apply #'format (append (list nil path) params)))
         (url (concatenate 'string "https://api.github.com" full-path))
         (headers `(("Authorization"
                     .
                     ,(concatenate 'string
                                   "token "
                                   (get-config :token))))))
    
    (multiple-value-bind (content code)
        (drakma:http-request
         url
         :force-binary t
         :connection-timeout 1
         :additional-headers headers)
      
      (let ((decoded (babel:octets-to-string content :encoding :utf-8)))
        (if (not (= code 200))
            (error (format nil "GitHub returned ~A status code." code)))
        (jonathan:parse decoded)))))


(defun get-nonmerged-commits (base fork)
  "Returns a list of strings with commit messages"

  (info "Getting nonmerged commits for ~A ~A" base fork)
  
  (let* ((data (get-data "/repos/~A/compare/~A:~A...~A:~A"
                         (repo-name base)
                         (repo-author base)
                         (repo-branch base)
                         (repo-author fork)
                         (repo-branch fork)))
         (commits (getf data :|commits|))
         (filtered-commits (if *ignore-merges*
                               (remove-if #'merge-commit-p commits)
                               commits))
         (messages (mapcar #'get-commit-message filtered-commits)))
    messages))


(defun get-repo-branch-names (repo)
  "Takes string like 'svetlyak40wt/foo' and
returns a list of strings like 'svetlyak40wt/foo@master',
'svetlyak40wt/foo@some-feature', etc."
  (let ((data (get-data "/repos/~A/branches" repo)))
    (mapcar (lambda (item)
              (concatenate 'string
                           repo
                           "@"
                           (getf item :|name|)))
            data)))


(defun get-repo-forks (repo)
  "Takes string like \"svetlyak40wt/foo\" and
returns a list of fork names strings like (list \"some-person/foo\" \"other/foo\")

TODO: add pagination"
  
  (let ((data (get-data "/repos/~A/forks" repo)))
    (mapcar (lambda (item)
              (getf item :|full_name|))
            data)))


(defun strip (text)
  "Removes spaces and newlines from both ends of the string"
  (string-trim '(#\Space #\Newline) text))


(defun split-header (text)
  "Separates first line from the rest and
returns a list of two items. First line should be separated
from the rest with at least one empty line."
  (let ((pos (position #\Newline text)))
    (if pos
        (list (strip (subseq text 0 pos))
              (strip (subseq text (1+ pos))))
        (list (strip text) ""))))


(defun print-commit (message)
  "Prints to stdout as a reStructured document's secion.
First line becomes a header, rest â€“ a body."
  (format t "~A~%~%"
          (beautify-sentence message)))


(defun analyze-branch (base branch-full-name)
  "Fetches from a github commit messages of commits
   Returns a plist like that:

   (list :name <short-name-of-the-branch>
         :commits (list <commits))"
  
  (list :name (repo-branch branch-full-name)
        :commits (get-nonmerged-commits base branch-full-name)))


(defun make-underline (char header)
  "Makes from given char a string of same length as text 'header'"
  (make-string (length header) :initial-element char))


(defun print-branch (branch)
  "Fetches from a github commit messages of commits

Then each commit message is printed to stdout as a reStructured
document's secion"
  
  (let ((commits (getf branch :commits))
        (branch-name (getf branch :name)))
    (format t "~A~%~A~%~%"
            branch-name
            (make-underline #\- branch-name))
    (mapc #'print-commit commits)
    nil))


(defun find-branch-by-name (branches name)
  "Searches in the list of full names like:

      '(\"12forks/core@master\"
        \"12forks/core@gh-pages\")

   branch by it's short name.

   For example, if name i \"gh-pages\", then
   function will return \"12forks/core@gh-pages\".

   If nothing found then nil is returned."
  (find-if (lambda (item)
             (equal (repo-branch item)
                name))
           branches))


(defun analyze-fork (base-branches fork-name)
  "Accepts a list of base's branches like:

     '(\"svetlyak40wt/django-fields@master\" \"svetlyak40wt/django-fields@gh-pages\")

   Returns a plist of fork data like
   '(:branches <branches-data> :name <fork-name>)

   Key :branches contains only branches having non merged
   to base commits."
  (info "Analyzing fork ~A" fork-name)
  (let* ((master-branch (find-branch-by-name base-branches "master"))
         (branche-names (get-repo-branch-names fork-name))
         (all-branches (progn
                           (info "  It has ~A branches" branche-names)
                          (mapcar (lambda (branch-full-name)
                                    (analyze-branch
                                     (or (find-branch-by-name base-branches (repo-branch branch-full-name))
                                         master-branch)
                                     branch-full-name))
                                  branche-names)))
         (good-branches (remove-if-not
                         (lambda (branch)
                           (getf branch :commits))
                         all-branches)))
    (list :name fork-name
          :branches good-branches)))


(defun print-fork (fork)
  (let ((branches (getf fork :branches))
        (name (getf fork :name)))
    (format t "~A~%~A~%~%" name (make-underline #\= name))
    (mapc (lambda (branch)
            (print-branch branch))
          branches)
    nil))



(defun analyze-repo (repo)
  "Returns a plist of fork which have unmerged commits:
   (list :name <repo-name> :forks <forks>"
  
  (let* ((fork-names (get-repo-forks repo))
         (repo-branches (get-repo-branch-names repo))
         (all-forks (mapcar (lambda (fork-name)
                          (analyze-fork repo-branches fork-name))
                            fork-names))
         (good-forks (remove-if-not
                      (lambda (fork)
                        (getf fork :branches))
                      all-forks)))
    (list :name repo
          :forks good-forks
          :total-forks-count (length all-forks)
          :good-forks-count  (length good-forks))))


(defun print-repo (repo)
  "Prints repo data in reStructured text format"
  (let* ((forks (getf repo :forks))
         (repo-name (getf repo :name))
         (underline (make-underline #\= repo-name)))
    
    (format t "~A~%~A~%~A~%~%"
            underline
            repo-name
            underline)
    
    (if forks
        (progn (mapc (lambda (fork)
                       (print-fork fork))
                     forks)
               nil)
        (format t "No forks"))))


(defsynopsis (:postfix "REPOSITORY")
  (text :contents "This utility builds a report about all non-merged commits for any github repository. Just give some repository name like \"antirez/redis\" as an argument and pipe stdout to some file.
")
  
  (flag :short-name "h" :long-name "help"
        :description "Print this help and exit.")
  (flag :short-name "v" :long-name "version"
        :description "Print version number and exit."))


(defun main (&rest args)
  (make-context :cmdline (cons "12forks" args))
  
  (when (getopt :short-name "v")
    (prin1 "12forks cli, version: 0.1.0")
    (exit))

  (when (getopt :long-name "help")
    (help)
    (exit))

  (read-config)

  (let ((repo (first (remainder))))
    (if repo
        (progn (let ((repo-data (analyze-repo repo)))
                 (print-repo repo-data)))
        (help))))

;;; vim: set ft=lisp lisp:
